import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useAppStore } from '../store/useAppStore';
import { PrecioSchema } from '../types/schemas';
import { preloadSchema } from '../api/schemas';

/**
 * Hook para datos en tiempo real con conexión directa al esquema XLSX
 * Permite actualizaciones automáticas sin recarga de página
 */
export const useRealTimeData = () => {
  const [isConnected, setIsConnected] = useState(false);
  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);
  const [schemaVersion, setSchemaVersion] = useState<string | null>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const eventSourceRef = useRef<EventSource | null>(null);

  // Inicializar conexión SSE para actualizaciones en tiempo real
  const connect = useCallback(() => {
    try {
      // Crear conexión EventSource para Server-Sent Events
      const eventSource = new EventSource('/api/sse/precios');
      eventSourceRef.current = eventSource;

      eventSource.onopen = () => {
        setIsConnected(true);
        console.log('[useRealTimeData] Conexión SSE establecida');
      };

      eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'schema_update') {
            // Recargar esquema cuando hay actualizaciones
            preloadSchema().then(() => {
              setSchemaVersion(data.version);
              setLastUpdate(new Date());
              console.log('[useRealTimeData] Esquema actualizado:', data.version);
            });
          } else if (data.type === 'price_update') {
            // Actualizar precios específicos
            console.log('[useRealTimeData] Actualización de precios:', data);
          }
        } catch (error) {
          console.error('[useRealTimeData] Error parseando mensaje SSE:', error);
        }
      };

      eventSource.onerror = () => {
        setIsConnected(false);
        console.error('[useRealTimeData] Error en conexión SSE');
        
        // Reconexión automática después de 5 segundos
        if (!reconnectTimeoutRef.current) {
          reconnectTimeoutRef.current = setTimeout(() => {
            reconnectTimeoutRef.current = null;
            connect();
          }, 5000);
        }
      };
    } catch (error) {
      console.error('[useRealTimeData] Error conectando SSE:', error);
    }
  }, []);

  // Desconectar al desmontar
  const disconnect = useCallback(() => {
    if (eventSourceRef.current) {
      eventSourceRef.current.close();
      eventSourceRef.current = null;
    }
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    setIsConnected(false);
  }, []);

  // Conectar al montar
  useEffect(() => {
    connect();
    return () => disconnect();
  }, [connect, disconnect]);

  return {
    isConnected,
    lastUpdate,
    schemaVersion,
    reconnect: () => {
      disconnect();
      setTimeout(connect, 100);
    }
  };
};

/**
 * Hook para sincronización periódica con fallback a polling
 */
export const usePollingSync = <T,>(
  fetchFn: () => Promise<T>,
  intervalMs: number = 30000,
  enabled: boolean = true
) => {
  const [data, setData] = useState<T | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const intervalRef = useRef<NodeJS.Timeout | null>(null);

  const fetchData = useCallback(async () => {
    if (!enabled) return;
    
    try {
      setIsLoading(true);
      const result = await fetchFn();
      setData(result);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Error desconocido'));
    } finally {
      setIsLoading(false);
    }
  }, [fetchFn, enabled]);

  useEffect(() => {
    if (!enabled) return;
    
    // Primera carga
    fetchData();
    
    // Polling interval
    intervalRef.current = setInterval(fetchData, intervalMs);
    
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, [fetchData, intervalMs, enabled]);

  return { data, isLoading, error, refetch: fetchData };
};

export default useRealTimeData;
